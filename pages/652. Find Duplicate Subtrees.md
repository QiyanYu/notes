title:: 652. Find Duplicate Subtrees

- # Description
	- Given the `root` of a binary tree, return all **duplicate subtrees**.
	  
	  For each kind of duplicate subtrees, you only need to return the root node of any **one** of them.
	  
	  Two trees are **duplicate** if they have the **same structure** with the **same node values**.
	  
	   
	  
	  **Example 1:**
	  
	  ![](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)
	  
	  ```
	  **Input:** root = [1,2,3,4,null,2,4,null,null,4]
	  **Output:** [[2,4],[4]]
	  ```
	  
	  **Example 2:**
	  
	  ![](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)
	  
	  ```
	  **Input:** root = [2,1,1]
	  **Output:** [[1]]
	  ```
	  
	  **Example 3:**
	  
	  ![](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)
	  
	  ```
	  **Input:** root = [2,2,2,3,null,3,null]
	  **Output:** [[2,3],[3]]
	  ```
	  
	   
	  
	  **Constraints:**
	- The number of the nodes in the tree will be in the range `[1, 5000]`
	- `-200 <= Node.val <= 200`
- # Solution 1: Serialize Binary Tree
	- ```java
	  // time:  O(N^2)
	  // space: O(N)
	  class Solution {
	      public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
	          Map<String, Integer> map = new HashMap<>();
	          List<TreeNode> res = new ArrayList<>();
	          dfs(root, map, res);
	          return res;
	      }
	  
	      private String dfs(TreeNode node, Map<String, Integer> map, List<TreeNode> res) {
	          if (node == null) {
	              return "null";
	          }
	  
	          StringBuilder sb = new StringBuilder();
	          sb.append(node.val).append(",");
	          sb.append(dfs(node.left, map, res)).append(",");
	          sb.append(dfs(node.right, map, res));
	          String path = sb.toString();
	          map.put(path, 1 + map.getOrDefault(path, 0));
	          if (map.get(path) == 2) {
	              res.add(node);
	          }
	  
	          return path;
	      }
	  }
	  ```