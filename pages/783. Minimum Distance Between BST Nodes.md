title:: 783. Minimum Distance Between BST Nodes

- # Description
	- Given the `root` of a Binary Search Tree (BST), return *the minimum difference between the values of any two different nodes in the tree*.
	  
	   
	  
	  **Example 1:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)
	  
	  ```
	  **Input:** root = [4,2,6,1,3]
	  **Output:** 1
	  ```
	  
	  **Example 2:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)
	  
	  ```
	  **Input:** root = [1,0,48,null,null,12,49]
	  **Output:** 1
	  ```
	  
	   
	  
	  **Constraints:**
	- The number of nodes in the tree is in the range `[2, 100]`.
	- `0 <= Node.val <= 105`
- # Solution 1: Recursion, DFS
	- ```java
	  // time:  O(N)
	  // space: O(N)
	  
	  class Solution {
	      public int minDiffInBST(TreeNode root) {
	          List<Integer> lst = new LinkedList<>();
	          inorder(root, lst);
	          int min = Integer.MAX_VALUE;
	          for (int i = 1; i < lst.size(); i++) {
	              min = Math.min(min, lst.get(i) - lst.get(i - 1));
	          }
	          return min;
	      }
	  
	      private void inorder(TreeNode root, List<Integer> lst) {
	          if (root == null) {
	              return;
	          }
	          inorder(root.left, lst);
	          lst.add(root.val);
	          inorder(root.right, lst);
	      }
	  }
	  ```
- # Solution 2: Iteration
	- ```java
	  // time:  O(N)
	  // space: O(N)
	  class Solution {
	      public int minDiffInBST(TreeNode root) {
	          List<Integer> lst = new LinkedList<>();
	          Deque<TreeNode> stk = new LinkedList<>();
	  
	          while (root != null || !stk.isEmpty()) {
	              if (root != null) {
	                  stk.push(root);
	                  root = root.left;
	              } else {
	                  TreeNode curr = stk.pop();
	                  lst.add(curr.val);
	                  root = curr.right;
	              }
	          }
	  
	          int min = Integer.MAX_VALUE;
	          for (int i = 1; i < lst.size(); i++) {
	              min = Math.min(min, lst.get(i) - lst.get(i - 1));
	          }
	  
	          return min;
	      }
	  }
	  ```
- # Solution 3: Morris Traversal
	- ```java
	  // time:  O(N)
	  // space: O(N)
	  class Solution {
	      public int minDiffInBST(TreeNode root) {
	          List<Integer> lst = new LinkedList<>();
	          TreeNode predecessor = null;
	          while (root != null) {
	              if (root.left != null) {
	                  predecessor = root.left;
	                  while (predecessor.right != null) {
	                      predecessor = predecessor.right;
	                  }
	                  predecessor.right = root;
	                  TreeNode tmp = root;
	                  root = root.left;
	                  tmp.left = null;
	              } else {
	                  lst.add(root.val);
	                  root = root.right;
	              }
	          }
	  
	          int min = Integer.MAX_VALUE;
	          for (int i = 1; i < lst.size(); i++) {
	              min = Math.min(min, lst.get(i) - lst.get(i - 1));
	          }
	  
	          return min;
	      }
	  }
	  ```