title:: 1129. Shortest Path with Alternating Colors

- ## Description
	- You are given an integer `n`, the number of nodes in a directed graph where the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.
	  
	  You are given two arrays `redEdges` and `blueEdges` where:
	- `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and
	- `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.
	  
	  Return an array `answer` of length `n`, where each `answer[x]` is the length of the shortest path from node `0` to node `x` such that the edge colors alternate along the path, or `-1` if such a path does not exist.
	  
	  
	  
	  **Example 1:**
	  
	  ```
	  **Input:** n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
	  **Output:** [0,1,-1]
	  ```
	  
	  **Example 2:**
	  
	  ```
	  **Input:** n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
	  **Output:** [0,1,-1]
	  ```
	  
	  
	  
	  **Constraints:**
	- `1 <= n <= 100`
	- `0 <= redEdges.length, blueEdges.length <= 400`
	- `redEdges[i].length == blueEdges[j].length == 2`
	- `0 <= ai, bi, uj, vj < n`
- ## Solution Approach
	- One approach to solve the problem is by running separate single source BFS for the red and blue colors.
	- Another method is to use multi-source BFS, simultaneously starting the search for both red and blue.
	- In Single Source BFS, if we don't store the `color` information in the BFS queue, we need to process one layer at a time by adding an inner while loop within the outer while loop as follows: `int size = q.size(); while (size-- > 0)`.
- ## Code Details
	- ### Using `mapping[]` to select corresponding color's edges.
	- ### Flip color:
		- `int RED = 0, int BLUE = 1`, `flipColor = 1 - color`
	- ### To store information about the edges (FROM and TO), we have two options:
	  :LOGBOOK:
	  CLOCK: [2023-02-11 Sat 16:34:10]
	  :END:
		- Option 1: `Map<Integer, List<Integer>[]`
			- This requires checking if the map has the key during iteration.
		- Option 2: `List<Integer>[][]`
			- This doesn't require checking for an empty key, but all elements in the array need to be initialized beforehand.
- ## Solution 1: two Single Source BFS
	- ```java
	  提交的代码： 10 天前
	  语言： java
	  
	  添加备注
	  
	  
	  class Solution {
	      private final int RED = 0;
	      private final int BLUE = 1;
	      private final int FROM = 0;
	      private final int TO = 1;
	      private final int CURR = 0;
	      private final int DIST = 1;
	      private final int COLOR = 2;
	  
	      public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {
	          List<Integer>[][] edges = new List[2][n];
	          for (int i = 0; i < n; i++) {
	              edges[RED][i] = new ArrayList<>();
	              edges[BLUE][i] = new ArrayList<>();
	          }
	          for (int[] r : redEdges) {
	              edges[RED][r[FROM]].add(r[TO]);
	          }
	          for (int[] b : blueEdges) {
	              edges[BLUE][b[FROM]].add(b[TO]);
	          }
	          int[] answer = new int[n];
	          Arrays.fill(answer, Integer.MAX_VALUE);
	          answer[0] = 0;
	          bfs(0, RED, edges, answer);
	          bfs(0, BLUE, edges, answer);
	  
	          for (int i = 0; i < n; i++) {
	              if (answer[i] == Integer.MAX_VALUE) {
	                  answer[i] = -1;
	              }
	          }
	          return answer;
	          }
	  
	      private void bfs(int start, int color, List<Integer>[][] edges, int[] answer) {
	          // int[]{currNode, distance}
	          Queue<int[]> q = new LinkedList<>();
	          //marked[]{color, adjacentNode}
	          boolean[][] marked = new boolean[2][answer.length];
	          q.offer(new int[]{start, 0});
	  
	          while (!q.isEmpty()) {
	              int size = q.size();
	              // visit one layer first
	              while (size-- > 0) {
	                  int temp[] = q.poll();
	                  int currNode = temp[CURR];
	                  int distance = temp[DIST];
	  
	                  for (int adj : edges[color][currNode]) {
	                      if (marked[color][adj]) {
	                          continue;
	                      }
	                      if (distance + 1 < answer[adj]) {
	                          answer[adj] = distance + 1;
	                      }
	                      marked[color][adj] = true;
	                      q.offer(new int[]{adj, distance + 1});
	                  }
	              }
	              color = 1 - color; // flip the color
	          }
	      }
	  }
	  ```