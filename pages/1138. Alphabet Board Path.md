title:: 1138. Alphabet Board Path

- ## Description
	- On an alphabet board, we start at position `(0, 0)`, corresponding to character `board[0][0]`.
	  
	  Here, `board = ["abcde", "fghij", "klmno", "pqrst", "uvwxy", "z"]`, as shown in the diagram below.
	  
	  ![](https://assets.leetcode.com/uploads/2019/07/28/azboard.png)
	  
	  We may make the following moves:
	- `'U'` moves our position up one row, if the position exists on the board;
	- `'D'` moves our position down one row, if the position exists on the board;
	- `'L'` moves our position left one column, if the position exists on the board;
	- `'R'` moves our position right one column, if the position exists on the board;
	- `'!'` adds the character `board[r][c]` at our current position `(r, c)` to the answer.
	  
	  (Here, the only positions that exist on the board are positions with letters on them.)
	  
	  Return a sequence of moves that makes our answer equal to `target` in the minimum number of moves.  You may return any path that does so.
	  
	  
	  
	  **Example 1:**
	  
	  ```
	  **Input:** target = "leet"
	  **Output:** "DDR!UURRR!!DDD!"
	  ```
	  
	  **Example 2:**
	  
	  ```
	  **Input:** target = "code"
	  **Output:** "RR!DDRR!UUL!R!"
	  ```
	  
	  
	  
	  **Constraints:**
	- `1 <= target.length <= 100`
	- `target` consists only of English lowercase letters.
- ## Solution Approach
	- To ensure access to `z`, it is necessary to prioritize moving orders by first going left and up, and then right and down. This approach will allow us to accommodate the unique conditions of `z`.
- ## Solution
	- ```java
	  // time:  O(n)
	  // space: O(n)
	  class Solution {
	      private final static int ROW = 0;
	      private final static int COL = 1;
	    
	      public String alphabetBoardPath(String target) {
	          // Instead of utilizing a hashmap, 
	          // utilize a fixed-sized int array (int[][]) 
	          // for recording purposes.
	          // int[letter] {row, column}
	          int[][] mapping = new int[26][2];
	          for (int i = 0; i < 26; i++) {
	              mapping[i] = new int[] {i / 5, i % 5};
	          }
	  
	          int[] curr = mapping[0];
	          StringBuilder res = new StringBuilder();
	          for (char t : target.toCharArray()) {
	              int[] next = mapping[t - 'a'];
	              // Move to the left and upwards, 
	              // then to the right and downwards
	              int horzDiff = next[COL] - curr[COL];
	              int vertDiff = next[ROW] - curr[ROW];
	  
	              // go left
	              while (horzDiff < 0) {
	                  res.append('L');
	                  horzDiff += 1;
	              }
	              // go up
	              while (vertDiff < 0) {
	                  res.append('U');
	                  vertDiff += 1;
	              }
	              // go right
	              while (horzDiff > 0) {
	                  res.append('R');
	                  horzDiff -= 1;
	              }
	              // go down
	              while (vertDiff > 0) {
	                  res.append('D');
	                  vertDiff -= 1;
	              }
	              res.append('!');
	              curr = next;
	          }
	  
	          return res.toString();
	      }
	  }
	  ```