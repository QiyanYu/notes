title:: 226. Invert Binary Tree

- # Description
	- Given the `root` of a binary tree, invert the tree, and return *its root*.
	  
	   
	  
	  **Example 1:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)
	  
	  ```
	  **Input:** root = [4,2,7,1,3,6,9]
	  **Output:** [4,7,2,9,6,3,1]
	  ```
	  
	  **Example 2:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)
	  
	  ```
	  **Input:** root = [2,1,3]
	  **Output:** [2,3,1]
	  ```
	  
	  **Example 3:**
	  
	  ```
	  **Input:** root = []
	  **Output:** []
	  ```
	  
	   
	  
	  **Constraints:**
	- The number of nodes in the tree is in the range `[0, 100]`.
	- `-100 <= Node.val <= 100`
- # Solution 1: Recursion
	- ```java
	  class Solution {
	      public TreeNode invertTree(TreeNode root) {
	          if (root == null) {
	              return root;
	          }
	          TreeNode tmp = invertTree(root.left);
	          root.left = invertTree(root.right);
	          root.right = tmp;
	          return root;
	      }
	  }
	  ```
- # Solution 2: BFS
	- ```java
	  class Solution {
	      public TreeNode invertTree(TreeNode root) {
	          if (root == null) {
	              return root;
	          }
	          
	          Queue<TreeNode> q = new LinkedList<>();
	          q.offer(root);
	          while (!q.isEmpty()) {
	              TreeNode node = q.poll();
	              TreeNode tmp = node.right;
	              node.right = node.left;
	              node.left = tmp;
	              if (node.right != null) {
	                  q.offer(node.right);
	              }
	              if (node.left != null) {
	                  q.offer(node.left);
	              }
	          }
	          return root;
	      }
	  }
	  ```