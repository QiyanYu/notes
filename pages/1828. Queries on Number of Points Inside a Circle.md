title:: 1828. Queries on Number of Points Inside a Circle

- ## Description
	- You are given an array `points` where `points[i] = [xi, yi]` is the coordinates of the `ith` point on a 2D plane. Multiple points can have the **same** coordinates.
	  
	  You are also given an array `queries` where `queries[j] = [xj, yj, rj]` describes a circle centered at `(xj, yj)` with a radius of `rj`.
	  
	  For each query `queries[j]`, compute the number of points **inside** the `jth` circle. Points **on the border** of the circle are considered **inside**.
	  
	  Return *an array *`answer`*, where *`answer[j]`* is the answer to the *`jth`* query*.
	  
	   
	  
	  **Example 1:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png)
	  
	  ```
	  **Input:** points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]
	  **Output:** [3,2,2]
	  **Explanation: **The points and circles are shown above.
	  queries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.
	  ```
	  
	  **Example 2:**
	  
	  ![](https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-42-07.png)
	  
	  ```
	  **Input:** points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]
	  **Output:** [2,3,2,4]
	  **Explanation: **The points and circles are shown above.
	  queries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple.
	  ```
	  
	   
	  
	  **Constraints:**
	- `1 <= points.length <= 500`
	- `points[i].length == 2`
	- `0 <= x​​​​​​i, y​​​​​​i <= 500`
	- `1 <= queries.length <= 500`
	- `queries[j].length == 3`
	- `0 <= xj, yj <= 500`
	- `1 <= rj <= 500`
	- All coordinates are integers.
	  
	  
	  
	  **Follow up:** Could you find the answer for each query in better complexity than `O(n)`?
- ## Solution 1: Brute Force
	- ```java
	  class Solution {
	      private final int X = 0;
	      private final int Y = 1;
	      private final int RADIUS = 2;
	  
	      public int[] countPoints(int[][] points, int[][] queries) {
	          int qLen = queries.length;
	          int[] res = new int[qLen];
	          for (int i = 0; i < qLen; i++) {
	              int[] q = queries[i];
	              int cnt = 0;
	              for (int[] p : points) {
	                  if (dist(q[X], q[Y], p[X], p[Y]) <= q[RADIUS]) {
	                      cnt++;
	                  }
	              }
	              res[i] = cnt;
	          }
	          return res;
	      }
	  
	      private double dist(int x1, int y1, int x2, int y2) {
	          return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
	      }
	  }
	  ```
- ## Solution 2: Kd Tree
	- ```java
	  ```
	- More details: [[Lec25: Range Searching and Multi-Dimensional Data]]
	- [leetcode k-d tree](https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/solutions/1182639/K-D-tree-solution-+-Follow-up-with-solutions-overview-C++/)
	-