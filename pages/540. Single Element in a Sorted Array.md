title:: 540. Single Element in a Sorted Array

- # Description
	- You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
	  
	  Return *the single element that appears only once*.
	  
	  Your solution must run in `O(log n)` time and `O(1)` space.
	  
	   
	  
	  **Example 1:**
	  
	  ```
	  **Input:** nums = [1,1,2,3,3,4,4,8,8]
	  **Output:** 2
	  ```
	  
	  **Example 2:**
	  
	  ```
	  **Input:** nums = [3,3,7,7,10,11,11]
	  **Output:** 10
	  ```
	  
	   
	  
	  **Constraints:**
	- `1 <= nums.length <= 105`
	- `0 <= nums[i] <= 105`
- # Approach
	- Since we need to solve this problem in `O(logN)` time and `O(1)` space, and the array is sorted, we can intuitively think of using binary search.
	- We should also notice that if all elements have a pair, the pairs will be of the form `(even index, odd index)`. If there is a single element in the array, the first half of the array will still have this pattern, but the second half will have a reversed pattern of `(odd index, even index)`.
	- Usually, in binary search, we set `le = mi, ri = mi - 1`. However, in this case, doing so would cause us to skip the `mid` element, so we add `1` to both `le` and `ri` to avoid this issue.
- # Solution
	- ```java
	  class Solution {
	      public int singleNonDuplicate(int[] nums) {
	          int n = nums.length;
	          int le = 0, ri = n - 1;
	          while (le < ri) {
	              int mi = le + (ri - le) / 2;
	              // target at right half
	              if (mi % 2 == 0 && nums[mi] == nums[mi + 1] ||
	                  mi % 2 == 1 && nums[mi] == nums[mi - 1]) {
	                  le = mi + 1;
	              } else {
	                  ri = mi;
	              }
	          }
	          return nums[le];
	      }
	  }
	  ```