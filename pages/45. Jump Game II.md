title:: 45. Jump Game II

- ## Description
	- You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.
	  
	  Each element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:
	- `0 <= j <= nums[i]` and
	- `i + j < n`
	  
	  Return *the minimum number of jumps to reach *`nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.
	  
	  
	  
	  **Example 1:**
	  
	  ```
	  **Input:** nums = [2,3,1,1,4]
	  **Output:** 2
	  **Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
	  ```
	  
	  **Example 2:**
	  
	  ```
	  **Input:** nums = [2,3,0,1,4]
	  **Output:** 2
	  ```
	  
	  
	  
	  **Constraints:**
	- `1 <= nums.length <= 104`
	- `0 <= nums[i] <= 1000`
- ## Solution 1: Greedy
	- ```java
	  class Solution {
	      public int jump(int[] nums) {
	          int end = 0;
	          int maxPos = 0;
	          int steps = 0;
	          // No need to visit last item 
	          // [0] = 0
	          for (int i = 0; i < nums.length - 1; i++) {
	              maxPos = Math.max(maxPos, nums[i] + i);
	              if (i == end) {
	                  end = maxPos;
	                  steps++;
	              }
	          }
	          return steps;
	      }
	  }
	  ```
- ## Solution 2: Sliding Window
	- ```java
	  class Solution {
	      public int jump(int[] nums) {
	          int steps = 0;
	          int le = 0;
	          int ri = 0;
	          // No need to visit last item 
	          while (ri < nums.length - 1) {
	              int maxPos = 0;
	              for (int i = le; i <= ri; i++) {
	                  maxPos = Math.max(maxPos, nums[i] + i);
	              }
	              le = ri + 1;
	              ri = maxPos;
	              steps++;
	          }
	          return steps;
	      }
	  }
	  ```