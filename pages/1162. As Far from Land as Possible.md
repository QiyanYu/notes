title:: 1162. As Far from Land as Possible

- ## Description
	- Given an `n x n` `grid` containing only values `0` and `1`, where `0` represents water and `1` represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return `-1`.
	  
	  The distance used in this problem is the Manhattan distance: the distance between two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.
	  
	   
	  
	  **Example 1:**
	  
	  ![](https://assets.leetcode.com/uploads/2019/05/03/1336_ex1.JPG)
	  
	  ```
	  **Input:** grid = [[1,0,1],[0,0,0],[1,0,1]]
	  **Output:** 2
	  **Explanation:** The cell (1, 1) is as far as possible from all the land with distance 2.
	  ```
	  
	  **Example 2:**
	  
	  ![](https://assets.leetcode.com/uploads/2019/05/03/1336_ex2.JPG)
	  
	  ```
	  **Input:** grid = [[1,0,0],[0,0,0],[0,0,0]]
	  **Output:** 4
	  **Explanation:** The cell (2, 2) is as far as possible from all the land with distance 4.
	  ```
	  
	   
	  
	  **Constraints:**
	- `n == grid.length`
	- `n == grid[i].length`
	- `1 <= n <= 100`
	- `grid[i][j]` is `0` or `1`
- ## Solution Approach
	- [Leetcode cn ](https://leetcode.cn/problems/as-far-from-land-as-possible/solution/di-tu-fen-xi-by-leetcode-solution/)
	- [Leetcode com](https://leetcode.com/problems/as-far-from-land-as-possible/solutions/3043174/as-far-from-land-as-possible/?orderBy=most_votes)
- ## Solution 1: Native BFS
	- **Note:** Remember to add `visited[][]`, but can not use `Set<> visited`
	- TIme: $$O(N^4)$$
	- ```java
	  class Solution {
	      private final static int I = 0;
	      private final static int J = 1;
	      private final static int WATER = 0;
	      private final static int LAND = 1;
	  
	      public int maxDistance(int[][] grid) {
	          int n = grid.length;
	          int res = -1;
	          for (int i = 0; i < n; i++) {
	              for (int j = 0; j < n; j++) {
	                  if (grid[i][j] == WATER) {
	                      res = Math.max(res, bfs(grid, i, j));
	                  }
	              }
	          }
	          return res;
	      }
	  
	      private int bfs(int[][] grid, int i, int j) {   
	          Queue<int[]> q = new LinkedList<>();
	          
	          q.offer(new int[] {i, j});
	          // Set<int[]> marked = new HashSet<>();
	          // marked.add(new int[] {i, j});
	          boolean[][] marked = new boolean[grid.length][grid.length];
	          
	          while (!q.isEmpty()) {
	              int[] temp = q.poll();
	              int iIdx = temp[I];
	              int jIdx = temp[J];
	              marked[iIdx][jIdx] = true;
	              if (grid[iIdx][jIdx] == LAND) {
	                  return Math.abs(i - iIdx) + Math.abs(j - jIdx);
	              }
	              List<int[]> neighbors = getNeighbors(grid, iIdx, jIdx);
	              for (int[] n : neighbors) {
	                  // if (!marked.contains(n)) {
	                  if (!marked[n[I]][n[J]]) {
	                      q.offer(n);
	                      // marked.add(n);
	  
	                  }
	              }  
	          }
	  
	          return -1;
	      }
	  
	      private List<int[]> getNeighbors(int[][] grid, int i, int j) {
	          int n = grid.length;
	          List<int[]> res = new ArrayList<>();
	          int[][] directions = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
	          for (int[] d : directions) {
	              int newI = i + d[I];
	              int newJ = j + d[J];
	              if (0 <= newI && newI < n && 0 <= newJ && newJ < n) {
	                  res.add(new int[] {newI, newJ});
	              }
	          }
	          return res;
	      }
	  }
	  ```
- ## Solution 2: Multi-source BFS
	- ```java
	  ```