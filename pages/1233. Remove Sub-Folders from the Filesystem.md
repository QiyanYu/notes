title:: 1233. Remove Sub-Folders from the Filesystem

- ## Description
	- Given a list of folders `folder`, return *the folders after removing all **sub-folders** in those folders*. You may return the answer in **any order**.
	  
	  If a `folder[i]` is located within another `folder[j]`, it is called a **sub-folder** of it.
	  
	  The format of a path is one or more concatenated strings of the form: `'/'` followed by one or more lowercase English letters.
	- For example, `"/leetcode"` and `"/leetcode/problems"` are valid paths while an empty string and `"/"` are not.
	  
	  
	  
	  **Example 1:**
	  
	  ```
	  **Input:** folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
	  **Output:** ["/a","/c/d","/c/f"]
	  **Explanation:** Folders "/a/b" is a subfolder of "/a" and "/c/d/e" is inside of folder "/c/d" in our filesystem.
	  ```
	  
	  **Example 2:**
	  
	  ```
	  **Input:** folder = ["/a","/a/b/c","/a/b/d"]
	  **Output:** ["/a"]
	  **Explanation:** Folders "/a/b/c" and "/a/b/d" will be removed because they are subfolders of "/a".
	  ```
	  
	  **Example 3:**
	  
	  ```
	  **Input:** folder = ["/a/b/c","/a/b/ca","/a/b/d"]
	  **Output:** ["/a/b/c","/a/b/ca","/a/b/d"]
	  ```
	  
	  
	  
	  **Constraints:**
	- `1 <= folder.length <= 4 * 104`
	- `2 <= folder[i].length <= 100`
	- `folder[i]` contains only lowercase letters and `'/'`.
	- `folder[i]` always starts with the character `'/'`.
	- Each folder name is **unique**.
- ## Solution 1: Trie
	- The most efficient aspect of this code is the use of `int key` to map the index of the folder, allowing us to effortlessly retrieve the name of the path (found on lines 7, 22, and 32).
	- ```java
	  class Solution {
	      private class Trie {
	          private int key;
	          private Map<String, Trie> next;
	  
	          private Trie() {
	              key = -1;
	              next = new HashMap<>();
	          }
	      }
	  
	      public List<String> removeSubfolders(String[] folder) {
	          Trie root = new Trie();
	          for (int i = 0; i < folder.length; i++) {
	              String[] path = folder[i].substring(1).split("/");
	              Trie curr = root;
	              for (String p : path) {
	                  curr.next.putIfAbsent(p, new Trie());
	                  curr = curr.next.get(p);
	              }
	              // this is for retreve folder name 
	              curr.key = i;
	          }
	  
	          List<String> res = new ArrayList<>();
	          dfs(folder, res, root);
	          return res;
	      }
	  
	      private void dfs(String[] folder, List<String> res, Trie curr) {
	          if (curr.key != -1) {
	              res.add(folder[curr.key]);
	              return;
	          }
	          for (Trie next : curr.next.values()) {
	              dfs(folder, res, next);
	          }
	      }  
	  }
	  ```
- ## Solution 2: Sorting
	- No harm to sort if you have no idea.
	- ```java
	  // time:  O(nl*log(n))
	  // space: O(nl)
	  class Solution {
	      public List<String> removeSubfolders(String[] folder) {
	          Arrays.sort(folder);
	          List<String> res = new ArrayList<>();
	          res.add(folder[0]);
	          String prev = folder[0];
	          for (int i = 1; i < folder.length; i++) {
	              String name = folder[i];
	              int m = prev.length();
	              int n = name.length();
	              if (n <= m || !(name.substring(0, m).equals(prev) && name.charAt(m) == '/')) {
	                  res.add(name);
	                  prev = name;
	              }
	          }
	          return res;
	      }
	  }
	  ```